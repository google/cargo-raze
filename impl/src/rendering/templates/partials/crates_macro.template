# EXPERIMENTAL -- MAY CHANGE AT ANY TIME: A mapping of package names to a set of normal dependencies for the Rust targets of that package.
_DEPENDENCIES = {
{%- for workspace_member in workspace.workspace_members %}
{%- if workspace_member %}
    "{{ bazel_package_name }}/{{ workspace_member }}": {
{%- else %}
    "{{ bazel_package_name }}": {
{%- endif %}
{%- for crate in crates %}
{%- if not crate.is_proc_macro and workspace_member in crate.workspace_member_dependents %}
{%- set crate_name_sanitized = crate.pkg_name | replace(from="-", to="_") %}
        "{{ crate.pkg_name }}": "{{ crate.workspace_path_to_crate }}:{{ crate_name_sanitized }}",
{%- endif %}
{%- endfor %}
    },
{%- endfor %}
}

# EXPERIMENTAL -- MAY CHANGE AT ANY TIME: A mapping of package names to a set of proc_macro dependencies for the Rust targets of that package.
_PROC_MACRO_DEPENDENCIES = {
{%- for workspace_member in workspace.workspace_members %}
{%- if workspace_member %}
    "{{ bazel_package_name }}/{{ workspace_member }}": {
{%- else %}
    "{{ bazel_package_name }}": {
{%- endif %}
{%- for crate in crates %}
{%- if crate.is_proc_macro and workspace_member in crate.workspace_member_dependents %}
{%- set crate_name_sanitized = crate.pkg_name | replace(from="-", to="_") %}
        "{{ crate.pkg_name }}": "{{ crate.workspace_path_to_crate }}:{{ crate_name_sanitized }}",
{%- endif %}
{%- endfor %}
    },
{%- endfor %}
}

# EXPERIMENTAL -- MAY CHANGE AT ANY TIME: A mapping of package names to a set of normal dev dependencies for the Rust targets of that package.
_DEV_DEPENDENCIES = {
{%- for workspace_member in workspace.workspace_members %}
{%- if workspace_member %}
    "{{ bazel_package_name }}/{{ workspace_member }}": {
{%- else %}
    "{{ bazel_package_name }}": {
{%- endif %}
{%- for crate in crates %}
{%- if not crate.is_proc_macro and workspace_member in crate.workspace_member_dev_dependents %}
{%- set crate_name_sanitized = crate.pkg_name | replace(from="-", to="_") %}
        "{{ crate.pkg_name }}": "{{ crate.workspace_path_to_crate }}:{{ crate_name_sanitized }}",
{%- endif %}
{%- endfor %}
    },
{%- endfor %}
}

# EXPERIMENTAL -- MAY CHANGE AT ANY TIME: A mapping of package names to a set of proc_macro dev dependencies for the Rust targets of that package.
_DEV_PROC_MACRO_DEPENDENCIES = {
{%- for workspace_member in workspace.workspace_members %}
{%- if workspace_member %}
    "{{ bazel_package_name }}/{{ workspace_member }}": {
{%- else %}
    "{{ bazel_package_name }}": {
{%- endif %}
{%- for crate in crates %}
{%- if crate.is_proc_macro and workspace_member in crate.workspace_member_dev_dependents %}
{%- set crate_name_sanitized = crate.pkg_name | replace(from="-", to="_") %}
        "{{ crate.pkg_name }}": "{{ crate.workspace_path_to_crate }}:{{ crate_name_sanitized }}",
{%- endif %}
{%- endfor %}
    },
{%- endfor %}
}

def crate_deps(deps, package_name = None):
    """EXPERIMENTAL -- MAY CHANGE AT ANY TIME: Finds the fully qualified label of the requested crates for the package where this macro is called.

    WARNING: This macro is part of an expeirmental API and is subject to change.

    Args:
        deps (list): The desired list of crate targets.
        package_name (str, optional): The package name of the set of dependencies to look up.
            Defaults to `native.package_name()`.
    Returns:
        list: A list of labels to cargo-raze generated targets (str)
    """

    if not package_name:
        package_name = native.package_name()

    # Join both sets of dependencies
    dependencies = _flatten_dependency_maps([
        _DEPENDENCIES,
        _PROC_MACRO_DEPENDENCIES,
        _DEV_DEPENDENCIES,
        _DEV_PROC_MACRO_DEPENDENCIES,
    ])

    if not deps:
        return []

    missing_crates = []
    crate_targets = []
    for crate_target in deps:
        if crate_target not in dependencies[package_name]:
            missing_crates.append(crate_target)
        else:
            crate_targets.append(dependencies[package_name][crate_target])

    if missing_crates:
        fail("Could not find crates `{}` among dependencies of `{}`. Available dependencies were `{}`".format(
            missing_crates,
            package_name,
            dependencies[package_name],
        ))

    return crate_targets

def all_crate_deps(normal = False, normal_dev = False, proc_macro = False, proc_macro_dev = False, package_name = None):
    """EXPERIMENTAL -- MAY CHANGE AT ANY TIME: Finds the fully qualified label of all requested direct crate dependencies \
    for the package where this macro is called.

    If no parameters are set, all normal dependencies are returned. Setting any one flag will
    otherwise impact the contents of the returned list.

    Args:
        normal (bool, optional): If True, normal dependencies are included in the
            output list. Defaults to False.
        normal_dev (bool, optional): If True, normla dev dependencies will be
            included in the output list. Defaults to False.
        proc_macro (bool, optional): If True, proc_macro dependencies are included
            in the output list. Defaults to False.
        proc_macro_dev (bool, optional): If True, dev proc_macro dependencies are
            included in the output list. Defaults to False.
        package_name (str, optional): The package name of the set of dependencies to look up.
            Defaults to `native.package_name()`.

    Returns:
        list: A list of labels to cargo-raze generated targets (str)
    """

    if not package_name:
        package_name = native.package_name()

    # Determine the relevant maps to use
    all_dependency_maps = []
    if normal:
        all_dependency_maps.append(_DEPENDENCIES)
    if normal_dev:
        all_dependency_maps.append(_DEV_DEPENDENCIES)
    if proc_macro:
        all_dependency_maps.append(_PROC_MACRO_DEPENDENCIES)
    if proc_macro_dev:
        all_dependency_maps.append(_DEV_PROC_MACRO_DEPENDENCIES)

    # Default to always using normal dependencies
    if not all_dependency_maps:
        all_dependency_maps.append(_DEPENDENCIES)

    dependencies = _flatten_dependency_maps(all_dependency_maps)

    if not dependencies:
        return []

    return dependencies[package_name].values()

def _flatten_dependency_maps(all_dependency_maps):
    """Flatten a list of dependency maps into one dictionary.

    Dependency maps have the following structure:

    ```python
    DEPENDENCIES_MAP = {
        # The first key in the map is a Bazel package
        # name of the workspace this file is defined in.
        "package_name": {

            # An alias to a crate target.     # The label of the crate target the
            # Aliases are only crate names.   # alias refers to.
            "alias":                          "@full//:label",
        }
    }
    ```

    Args:
        all_dependency_maps (list): A list of dicts as described above

    Returns:
        dict: A dictionary as described above
    """
    dependencies = {}

    for dep_map in all_dependency_maps:
        for pkg_name in dep_map:
            if pkg_name not in dependencies:
                # Add a non-frozen dict to the collection of dependencies
                dependencies.setdefault(pkg_name, dict(dep_map[pkg_name].items()))
                continue

            duplicate_crate_aliases = [key for key in dependencies[pkg_name] if key in dep_map[pkg_name]]
            if duplicate_crate_aliases:
                fail("There should be no duplicate crate aliases: {}".format(duplicate_crate_aliases))

            dependencies[pkg_name].update(dep_map[pkg_name])

    return dependencies